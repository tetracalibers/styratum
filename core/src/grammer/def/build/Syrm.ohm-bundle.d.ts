// AUTOGENERATED FILE
// This file was generated from Syrm.ohm by `ohm generateBundles`.

import {
  ActionDict,
  Grammar,
  IterationNode,
  Namespace,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface BaseActionDict<T> extends ActionDict<T> {
  space?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Root?: (this: NonterminalNode, arg0: TerminalNode) => T;
  propsFunc?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  Formula_recursive?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  Formula?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FormulaElements_number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FormulaElements_expression?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  FormulaElements?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtomicFormula?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  numeral?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  numeralOnly_negative?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  numeralOnly_positive?: (this: NonterminalNode, arg0: IterationNode) => T;
  numeralOnly?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  numeralWithUnit?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  unit?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  mathOperator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  lowerCase?: (this: NonterminalNode, arg0: IterationNode) => T;
  kebabCase?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  pascalCase?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  camelCase?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  jsIdentifier?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  multiLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  singleLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  whitespace_verticalTab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace_formFeed?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace_noBreakSpace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace_byteOrderMark?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  lineTerminatorSequence?: (this: NonterminalNode, arg0: TerminalNode) => T;
  unicodeSpaceSeparator?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface BaseSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: BaseActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: BaseActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: BaseActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: BaseActionDict<T>): this;
}

export interface BaseGrammar extends Grammar {
  createSemantics(): BaseSemantics;
  extendSemantics(superSemantics: BaseSemantics): BaseSemantics;
}

export interface SyrmedCssActionDict<T> extends BaseActionDict<T> {
  syrmPrefixAnnotation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  syrmBetweenAnnotation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  syrmSuffixAnnotation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  truthyKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  falsyKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  existKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  elseKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  invertKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  collectionKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  PropertyValueBase?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PropertyValueFunc?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode) => T;
  constantSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  nth_basic?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: IterationNode) => T;
  nth_inject?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  nth?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  attributeSelector?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  htmlTagSelector?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  jsxTagSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  rootSelector?: (this: NonterminalNode, arg0: TerminalNode) => T;
  universalSelector?: (this: NonterminalNode, arg0: TerminalNode) => T;
  combinator?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  adjacentSiblijngCombinator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  generalSiblijngCombinator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  childCombinator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  columnCombinator?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface SyrmedCssSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: SyrmedCssActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: SyrmedCssActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: SyrmedCssActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: SyrmedCssActionDict<T>): this;
}

export interface SyrmedCssGrammar extends Grammar {
  createSemantics(): SyrmedCssSemantics;
  extendSemantics(superSemantics: SyrmedCssSemantics): SyrmedCssSemantics;
}

export interface SyrmCascadeActionDict<T> extends SyrmedCssActionDict<T> {
  Root?: (this: NonterminalNode, arg0: IterationNode) => T;
  Block_surrounded?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  Block_between?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  Block_prefixed?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Block_basic?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Block?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DeclarationsBlockWithPrefix?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  DeclarationsBlock?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  DeclarationList?: (this: NonterminalNode, arg0: IterationNode) => T;
  Declaration?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  propertyName?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PropertyValue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SelectorList?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  Selector?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  SelectorElem_edge?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  SelectorElem_node?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SelectorElem?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtomicSelector_composite?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  AtomicSelector_basic?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtomicSelector_omission?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtomicSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  basicSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoSelector_atom?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoSelector_molecule?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  PseudoSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Pseudo?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoFunc_element?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  PseudoFunc_class?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  PseudoFunc?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoElement?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PseudoClass?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PseudoArg?: (this: NonterminalNode, arg0: IterationNode | NonterminalNode) => T;
}

export interface SyrmCascadeSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: SyrmCascadeActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: SyrmCascadeActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: SyrmCascadeActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: SyrmCascadeActionDict<T>): this;
}

export interface SyrmCascadeGrammar extends Grammar {
  createSemantics(): SyrmCascadeSemantics;
  extendSemantics(superSemantics: SyrmCascadeSemantics): SyrmCascadeSemantics;
}

export interface SyrmCollectionActionDict<T> extends SyrmedCssActionDict<T> {
  Root?: (this: NonterminalNode, arg0: IterationNode) => T;
  Def?: (this: NonterminalNode, arg0: TerminalNode, arg1: Node, arg2: TerminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode, arg7: Node, arg8: TerminalNode) => T;
  Block_between?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  Block_prefixed?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Block_basic?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Block?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DeclarationsBlockWithPrefix?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  DeclarationsBlock?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  DeclarationList?: (this: NonterminalNode, arg0: IterationNode) => T;
  Declaration?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  propertyName?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PropertyValue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SelectorList?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  Selector?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  SelectorElem_edge?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  SelectorElem_node?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SelectorElem?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtomicSelector_composite?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  AtomicSelector_basic?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtomicSelector_omission?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtomicSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  basicSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoSelector_atom?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoSelector_molecule?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  PseudoSelector?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Pseudo?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoFunc_element?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  PseudoFunc_class?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  PseudoFunc?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PseudoElement?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PseudoClass?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PseudoArg?: (this: NonterminalNode, arg0: IterationNode | NonterminalNode) => T;
}

export interface SyrmCollectionSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: SyrmCollectionActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: SyrmCollectionActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: SyrmCollectionActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: SyrmCollectionActionDict<T>): this;
}

export interface SyrmCollectionGrammar extends Grammar {
  createSemantics(): SyrmCollectionSemantics;
  extendSemantics(superSemantics: SyrmCollectionSemantics): SyrmCollectionSemantics;
}

export interface SyrmActionDict<T> extends BaseActionDict<T> {
  Root?: (this: NonterminalNode, arg0: IterationNode) => T;
  Region?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Cascade?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode) => T;
  CascadeInnerOther?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Collection?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode) => T;
  CollectionInnerOther?: (this: NonterminalNode, arg0: TerminalNode) => T;
  inner?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface SyrmSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: SyrmActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: SyrmActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: SyrmActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: SyrmActionDict<T>): this;
}

export interface SyrmGrammar extends Grammar {
  createSemantics(): SyrmSemantics;
  extendSemantics(superSemantics: SyrmSemantics): SyrmSemantics;
}

declare const ns: {
  Base: BaseGrammar;
  SyrmedCss: SyrmedCssGrammar;
  SyrmCascade: SyrmCascadeGrammar;
  SyrmCollection: SyrmCollectionGrammar;
  Syrm: SyrmGrammar;
};
export default ns;

